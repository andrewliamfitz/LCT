\documentclass[12pt]{article}
\pdfoutput=1 
\usepackage{jheppub}
\usepackage{soul}
\usepackage{setspace}
\usepackage{slashed}   
\usepackage{graphicx,url}
\usepackage{booktabs}
\usepackage{bbm}
\usepackage{braket}
\usepackage{colortbl}
\usepackage{amsmath,hyperref,amssymb,cancel,stmaryrd}
\usepackage{amsfonts}
% \usepackage{amsmath}
% \usepackage{amssymb}
\usepackage{slashed}
\usepackage{mathrsfs}
\usepackage{verbatim}
\usepackage[usenames,dvipsnames]{xcolor}
%\documentclass[12pt]{article}
\usepackage{color} 
\let\normalcolor\relax  
\usepackage{epsfig} 
\def\half{\frac{1}{2}}
\def\cn{{\mathcal N}}
\def\tr{{\rm Tr}} 
\def\la{\lambda} 
\def\sl{\slashed} 
\def\lb{\bar{\lambda}}  
\def\m{\mu} 
\def\mb{\bar{\mu}}
\def\wb{\bar{w}}      
\def\e{\eta}
\def\ep{\epsilon} 
\def\a{\alpha}
\def\ad{\dot{\alpha}}
\def\ab{\bar{a}} 
\def\eb{\tilde{\eta}}
\def\Qb{\bar{Q}} 
\def\Or[#1]{{\text{O}}\left({#1}\right)}
\def\dotl[#1,#2]{\left\langle #1, #2 \right\rangle}
\def\dotlb[#1,#2]{[ #1, #2 ]}
\def\dotp[#1,#2]{(#1) \cdot (#2)}
\def\aff[#1,#2]{\hat{#1}(#2)}
\def\n4sym{{\cal N}=4 SYM}
\def\>{\rangle}
\def\<{\langle}
\newcommand   \corr   [1] {\left\langle #1 \right\rangle }
\newcommand   \inner [2] {\< #1 | #2 \>}
\newcommand   \pa [1] {\left( #1 \right)}
\def\weight[#1,#2,#3]{\{(#1),#2,#3\}}
\def\ads[#1]{$\text{AdS}_{#1}$}
\def\lrdel{\overset{\leftrightarrow}{\nabla}}
\newcommand{\vect}[1]{{\bf{#1}}}
\newcommand{\ba}{\begin{eqnarray}}
\newcommand{\ea}{\end{eqnarray}}
\newcommand{\bal}{\begin{aligned}}
\newcommand{\eal}{\end{aligned}}
\newcommand{\be}{\begin{eqnarray}}
\newcommand{\ee}{\end{eqnarray}}
\newcommand{\bq}{\begin{equation}}
\newcommand{\eq}{\end{equation}}
\newcommand{\benn}{\begin{equation*}}
\newcommand{\eenn}{\end{equation*}}
\newcommand{\bi}{\begin{itemize}}  
\newcommand{\ei}{\end{itemize}}
\renewcommand{\d}{\partial}
\newcommand{\Poincare}{Poincar\'{e} }
\newcommand{\Acal}{{\mathcal A}} 
\newcommand{\Bcal}{{\mathcal B}}
\newcommand{\Ccal}{{\mathcal C}}
\newcommand{\Dcal}{{\mathcal D}}
\newcommand{\Ecal}{{\mathcal E}}
\newcommand{\Fcal}{{\mathcal F}}
\newcommand{\Gcal}{{\mathcal G}}
\newcommand{\Hcal}{{\mathcal H}}
\newcommand{\Ical}{{\mathcal I}} 
\newcommand{\Jcal}{{\mathcal J}}
\newcommand{\Kcal}{{\mathcal K}}
\newcommand{\Lcal}{{\mathcal L}}
\newcommand{\Mcal}{{\mathcal M}}
\newcommand{\Ncal}{{\mathcal N}}
\newcommand{\cN}{{\mathcal N}}
\newcommand{\Ocal}{{\mathcal O}}
\newcommand{\cO}{{\mathcal O}}
\newcommand{\Pcal}{{\mathcal P}}
\newcommand{\Qcal}{{\mathcal Q}}
\newcommand{\Rcal}{{\mathcal R}}
\newcommand{\Scal}{{\mathcal S}}
\newcommand{\Tcal}{{\mathcal T}}
\newcommand{\Ucal}{{\mathcal U}}
\newcommand{\Vcal}{{\mathcal V}}
\newcommand{\Wcal}{{\mathcal W}}
\newcommand{\Xcal}{{\mathcal X}}
\newcommand{\Ycal}{{\mathcal Y}}
\newcommand{\Zcal}{{\mathcal Z}}
\newcommand{\CA}{{\cal A}}
\newcommand{\CS}{{\cal S}}
\newcommand{\CC}{{\cal C}}
\newcommand{\CE}{{\cal E}}
\newcommand{\CF}{{\cal F}}
\newcommand{\CI}{{\cal I}}
\newcommand{\CL}{{\cal L}}
\newcommand{\CJ}{{\cal J}}
\newcommand{\CM}{{\cal M}}
\newcommand{\CN}{{\cal N}}
\newcommand{\CO}{{\cal O}}
\newcommand{\CP}{{\cal P}}
\newcommand{\CR}{{\cal R}}
\newcommand{\CV}{{\cal V}}
\newcommand{\nn}{\nonumber}
\renewcommand{\Im}[0]{\operatorname{Im}}
\renewcommand{\Re}[0]{\operatorname{Re}}
\newcommand{\blue}{\bf\color{blue}}
\newcommand{\red}{\bf\color{red}}
\newcommand{\magenta}{\bf\color{magenta}}
\newcommand\draftnote[1]{{\blue #1}}
\newcommand\oo\infty
\newcommand\s\sigma
\newcommand\de\delta
\newcommand\De\Delta
%\newcommand\p[1]{\left(#1\right)}
\newcommand{\p}{\partial}
\newcommand\f\phi
\newcommand\g\gamma
\newcommand\x\times
\newcommand{\nin}{\noindent}
\newcommand{\ra}{\rightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\fr}{\frac}
\newcommand{\comm}[2]{[#1,#2]}
\newcommand{\acomm}[2]{\{#1,#2\}}
\newcommand{\AdS}{\textrm{AdS}}
\newcommand{\CFT}{\textrm{CFT}}
\newcommand{\tfr}{\tfrac}
\newcommand{\KL}{K\"{a}ll\'{e}n-Lehmann }
\newcommand{\zb}{\bar{z}}
\newcommand{\sgn}{{\rm sgn}}
\newcommand{\eff}{\textrm{eff}}
\newcommand{\gap}{\textrm{gap}}
\newcommand{\ET}{\textrm{ET}}
\newcommand{\LC}{\textrm{LC}}
\newcommand{\eps}{\varepsilon}
\newcommand{\Cmax}{\Ccal_{\max}}
\newcommand{\Dmax}{\De_{\max}}
\newcommand\lrpar{\raise .8ex\hbox{$^\leftrightarrow$} \hspace{-9pt}
\partial}
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}

\newcommand\G{\Gamma}
\newcommand\R{\mathbb{R}}
\renewcommand\th{\theta}
\newcommand{\gp}{\mathfrak{q}}
\newcommand{\tB}{\widetilde{\Bcal}}
\newcommand{\Chat}{\widehat{C}}

\newcommand{\bk}{\boldsymbol{k}}
\newcommand{\bl}{\boldsymbol{\ell}}
\newcommand{\bs}{\boldsymbol{\sigma}}
\newcommand{\dagg}{\dagger}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\Tr}{\textrm{Tr}}
\newcommand{\Sun}{SU($N$)}
\newcommand{\Psibar}{\overline{\Psi}}
\newcommand{\wh}{\widehat}
\newcommand{\rket}[1]{\ket{#1}_{\rm RQ}}


\usepackage{listings}
\lstset{language=Mathematica}

\usepackage{xcolor}
\usepackage{mdframed}

\usepackage{mmacells} 
\mmaSet{
  leftmargin=2.3em,
  labelsep=-0.8em,
}

\usepackage{afterpage}
\usepackage{bookmark}



\newenvironment{monospace}{\ttfamily}{\par}
\newenvironment{code}{\begin{monospace}\begin{tabbing}}{\end{tabbing}\end{monospace}}



\newcommand{\Ft}{\widetilde{F}}
\newcommand{\onevec}{\boldsymbol{1}}
\newcommand{\twovec}{\boldsymbol{2}}
\newcommand{\Bvec}{\boldsymbol{\beta}}
\newcommand{\Lvec}{\boldsymbol{\ell}}
\newcommand{\J}{{\mathscr J}}
\newcommand{\kvec}{\boldsymbol{k}}
\newcommand{\yvec}{\boldsymbol{k}}
\newcommand{\pvec}{\boldsymbol{p}}
\newcommand{\pr}[1]{\left(#1 \right)}


\newcommand{\ptl}{\partial}
\newcommand{\Kvec}{\boldsymbol{k}}

%%%%%%%%%%%%%%% yuan








\makeatletter
\def\@fpheader{\vspace{-.1cm}}
\makeatother





\title{
Users' Guide for LCT Code
}




\author[a]{Nikhil Anand,}
\author[b]{A. Liam Fitzpatrick,}
\author[b]{Emanuel Katz,}
\author[b,c]{Zuhair U. Khandker,}
\author[d,e]{Matthew T. Walters,}
\author[b]{Yuan Xin}

\affiliation[a]{Department of Physics, McGill University, Montr\'eal, QC H3A 2T8, Canada}
\affiliation[b]{Department of Physics, Boston University, Boston, MA 02215, USA}
\affiliation[c]{Department of Physics, University of Illinois, Urbana, IL 61801, USA}
\affiliation[d]{Theoretical Physics Department, CERN, 1211 Geneva 23, Switzerland}
\affiliation[e]{Institute of Physics, \'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), CH-1015 Lausanne,
Switzerland}

%\author{The Lightcone Conformal Truncation Collaboration}




%\affiliation[a]{Department of Physics, Boston University, \\
%Commonwealth Avenue, Boston, MA 02215, USA}


%\abstract{We should probably think of a catchy name or abbreviation for our code.
%}

\arxivnumber{}


\begin{document}

\maketitle  


\newpage
\section{Overview}

Here we provide an overview of the packages provided in the code, as well as demonstrations for how to run each of them and how to reproduce most of the numeric results in the paper.  The interactions covered by the packages are 
\begin{itemize}
\item $\phi^n$ for $n=2,3,4$ in a theory with a scalar as well as a theory with a scalar and a fermion,
\item The fermion mass term $\sim \psi \frac{1}{\partial} \psi$ in a theory with a fermion as well as a theory with a scalar and a fermion,
\item A Yukawa interaction $\sim \phi \psi \chi$ in a theory with a scalar and a fermion,
\item The supercharges $Q_+, Q_-$ in a theory with a scalar and a fermion, for a $\phi^2$ and $\phi^3$ superpotential.
\end{itemize}
In subsection \ref{sec:2dQCD}, we also describe a package and its demonstration for computing matrix elements in 2d QCD at finite $N_c$ in the absence of a quark mass term.


\section{Packages}

To use any of the packages listed below, first make sure that the package is in the correct directory (e.g. {\tt NotebookDirectory[]}). Then, import the package with the command \begin{mmaCell}[moredefined={<< "./PackageName.wl"}]{Input}
  << "./PackageName.wl"
\end{mmaCell}

\subsection{{\tt Basis-Scalar.wl}}

The package  {\tt Basis-Scalar.wl} contains the routines needed to compute the scalar basis. The main function the user can call is {\tt computeBosonBasis[}$\Delta_{\textrm{max} } $, {\tt prec]} which computes the scalar basis up to the maximum scaling dimension $\Dmax$, using numerical precision {\tt prec} when orthogonalizing states.
The basis is saved to the public variable {\tt basisBoson}, where the basis states are orthonormalized numerically, as well as the public variable {\tt basisBosonPre}, where the basis states are not orthonormalized.  The advantage of {\tt basisBosonPre} is that prior to orthonormalization, the primaries can be written as sums over monomials with rational coefficients and therefore it has infinite precision, allowing one to choose the numerical precision  of the orthonormalization at a later time.

The organization of {\tt basisBoson} is, in particular,
\begin{itemize}
%\item {\tt monomialsBoson[n,deg]} returns the list of scalar monomials at particle number {\tt n} and degree {\tt deg}.
\item {\tt basisBoson[[1,deg+1,n]]} returns the basis states for particle number {\tt n} and degree {\tt deg} as a matrix whose rows correspond to different basis states, whose columns are monomials ordered according to {\tt monomialsBoson[n,deg]}, and whose entries tell us the expansion of the basis states in terms of monomials. 
\end{itemize}
For example, for {\tt n=3} and {\tt deg=2}, we have 
\begin{mmaCell}[moredefined={monomialsBoson,basisBoson}]{Input}
  n=3; deg=2; 
  monomialsBoson[n,deg]
  basisBoson[[1,deg+1,n]]
\end{mmaCell}
\begin{mmaCell}{Output}
  \{\{3,1,1\}, \{2,2,1\}\}
  \{\{0.755929,-0.654654\}\}
\end{mmaCell}
which tells us that there is a single primary operator at this level given by 
\be
\ket{\CO} = 0.755929 \rket{ \p^3 \phi (\p\phi)^2 } -0.654654 \rket{ (\p^2 \phi)^2 \p\phi}  . 
\label{eq:ExampleScalarPrimary}
\ee

The normalization convention for monomials used in {\tt Basis-Scalar.wl} is
\be
\rket{ \p^{\kvec} \phi } \equiv \frac{1}{\CN_{\kvec} \norm{\kvec} } \p^{\kvec}\phi(0) \ket{\rm vac}  \quad  \Rightarrow \quad \left( \rket{\p^{\bk'} \phi} \right)^\dagger \cdot \rket{\p^{\bk} \phi} = \delta_{\bk, \bk'}, 
\label{eq:CodeMonNormalization}
\ee
where we are using the notation introduced in section 7.2 of the paper and $\dagger$ is Hermitian conjugation in the standard radial quantization sense. %With this choice, $\ket{ \p^{\kvec} \phi}_c$ has unit radial-quantization norm, which is convenient for numerically implementing the Radial Quantization Method. 
If needed, we can easily convert (\ref{eq:ExampleScalarPrimary}) back to a position space operator using (\ref{eq:CodeMonNormalization}). Letting $\bk_1=(3,1,1)$ and $\bk_2 = (2,2,1)$, we have
\be
\CO(x) = \frac{0.755929}{\CN_{\kvec_1} \norm{\kvec_1}} \p^{\bk_1}\phi(x) - \frac{0.654654}{\CN_{\kvec_2} \norm{\kvec_2}} \p^{\bk_2}\phi(x) \propto  6 \p^{\bk_1}\phi(x) - 9 \p^{\bk_2}\phi(x).
\label{eq:ExamplePositionSpace}
\ee
This is the operator $\CO_{(2,0)}$ (or equivalently $\CO_{(0,2)}$) appearing in Table 2 of the paper. 

{\bf Note}: Much as the primary states $\CO(0)| {\rm vac}\>$ in radial quantization are different from the primary states $|\CO, p\>$ in momentum space, the monomial states $\rket{ \p^{\kvec} \phi }$ in radial quantization are different from the monomial states $|\p^{\kvec} \phi, p\>$ in momentum space, with different inner product matrices (for instance $\left( | \p^{\kvec '} \phi, p' \> \right)^\dagger \cdot | \p^{\kvec} \phi, p \>$ does not vanish for $\kvec \ne \kvec'$, in contrast with (\ref{eq:CodeMonNormalization})) and different meanings for Hermitian conjugation.  Consequently, the relative coefficients of different monomials in the decomposition of a primary operator $\CO$ depend on which representation of the operator is used:
\be
\CO(x) &=& \sum_{\bk} C_{\bk}^{\CO} \p^{\bk} \phi(x) , \nn\\
| \CO, p \> &=&  \sum_{\bk} \frac{C_{\bk}^{\CO} N_k}{N_{\CO}} | \p^{\bk} \phi, p\> \equiv \sum_{\bk} \wh{C}_k^{\CO} | \p^{\bk} \phi, p \> , \nn\\
\CO(0) | \textrm{vac} \> &=& \sum_{\bk} C_{\bk}^{\CO} \CN_{\bk} \norm{\bk}  \rket{\p^{\bk} \phi}.
\ee
 The reader should keep this in mind if comparing the above decomposition of $\CO_{(2,0)}$ to that in section 4.2 (for instance, in Table 5) of the paper, where momentum-space monomials are used.  
%Do not compare this with Table 5 of the paper because the normalization is different.
% This corresponds to the operator at $n=3$, $\Delta=5$ in Table 5 of the paper. Recall that our convention in the code is to normalize operators according to the Zamolodchikov metric. 

\subsection{{\tt Basis-Fermion.wl}}

The package  {\tt Basis-Fermion.wl} contains the routines needed to compute the fermion basis. The main function the user can call is {\tt computeFermionBasis[}$\Delta_{\textrm{max} } $, {\tt prec]} or {\tt computeFermionBasis[}$\Delta_{\textrm{max} } $, {\tt prec, SUSY->True]}, which computes the fermion basis up to $\Dmax$, using numerical precision {\tt prec} when orthogonalizing states. The meaning of $\Dmax$ depends on the option {\tt SUSY} (default {\tt SUSY->False}):
\begin{itemize}
\item For option {\tt SUSY->False}, $\Dmax =$ {\tt deg+3/2n} is  the maximum scaling dimension, where {\tt n} is the particle number and {\tt deg} is the degree  
\item For option {\tt SUSY->True}, we define $\Dmax=$ {\tt deg+n}, so that the truncation is compatible with supersymmery.
\end{itemize}
The basis is saved to the public variable {\tt basisFermion}.  The organization of {\tt basisFermion} is analogous to that of its scalar counterpart {\tt basisBoson}. In particular,
\begin{itemize}
%\item {\tt monomialsFermion[n,deg]} returns the list of fermion monomials at particle number {\tt n} and degree {\tt deg}.
\item {\tt basisFermion[[1,deg+1,n]]} returns the basis states for particle number {\tt n} and degree {\tt deg} as a matrix whose rows correspond to different basis states, whose columns are monomials ordered according to {\tt monomialsFermion[n,deg]}, and whose entries tell us the expansion of the basis states in terms of monomials. 
\end{itemize}
For example, for {\tt n=2} and {\tt deg=3}, we have 
\begin{mmaCell}[moredefined={monomialsFermion,basisFermion}]{Input}
  n=2; deg=3; 
  monomialsFermion[n,deg]
  basisFermion[[1,deg+1,n]]
\end{mmaCell}
\begin{mmaCell}{Output}
  \{\{4,1\},\{3,2\}\}
  \{\{-0.408248,0.912871\}\}
\end{mmaCell}
which tells us that there is a single primary operator at this level given by 
\begin{equation*}
\ket{\CO} = -0.408248 \rket{ \p^4 \psi \p^2\psi } + 0.912871 \rket{ \p^3 \psi \p^2 \psi  }. 
\end{equation*}
Just like in {\tt Basis-Scalar.wl}, monomials in {\tt Basis-Fermion.wl} are normalized according to (\ref{eq:CodeMonNormalization}). Taking this into account, we can convert the operator above to position space if desired, as was done for the scalar example in (\ref{eq:ExamplePositionSpace}). One finds that the operator above corresponds to the operator called $\CO_{(3)}$ in Table 11 of the paper. 

The routines in {\tt Basis-Fermion.wl} make frequent use of a correspondence between fermion and scalar monomials. As discussed in section 5.2 of the paper, there is a one-to-one mapping between fermion monomials of degree {\tt deg} and scalar monomials of degree {\tt  bDeg}, where 
\begin{equation*}
{\tt bDeg = deg - n(n-1)/2 }
\end{equation*}
%A common strategy for working with fermion monomials in {\tt Basis-Fermion.wl} is to map them to scalar monomials and work with the latter instead. 

\subsection{{\tt Basis-Mixon.wl}}
The package  {\tt Basis-Mixon.wl} contains the routines needed to compute the mixon basis. The main function the user can call is \\
{\tt computeMixonBasis[}$\Delta_{\textrm{max} } $,{\tt basisBoson,basisFermion]} \\
or {\tt computeMixonBasis[}$\Delta_{\textrm{max} } $,{\tt basisBoson,basisFermion,SUSY->True]},\\ 
which computes the mixon basis up to $\Dmax$. The meaning of $\Dmax$ depends on the option {\tt SUSY} (default {\tt SUSY->False}), and is the same as described above for  {\tt Basis-Fermion.wl}.
%\begin{itemize}
%\item For option {\tt SUSY->False}, $\Dmax$ is  the maximum scaling dimension. 
%\item For option {\tt SUSY->True}, we define $\Dmax=$ {\tt deg+n}, so that the truncation is compatible with supersymmery.
%\end{itemize}

The structure of the mixon basis is such that
    {\tt basisMixon[[nB+1,nF+1]]}
contains the set of levels in that particle number sector.
Each level corresponds to a certain combination of {\tt \{degB,degF,l\}},
where
\begin{itemize}
\item {\tt degB} is the degree of the scalar primary state $\CO_B$ that the mixon primary is built upon.
\item {\tt degF} is that of the fermion primary state $\CO_F$
\item {\tt l} is the number of alternating derivative taken in the construction $\CO_B \lrpar^\ell \CO_F$ .
\end{itemize}

For example, in the sector {\tt (nB=1, nF=0)} there is only one primary level, containing only one 
primary state.
\begin{mmaCell}[moredefined={basisMixon}]{Input}
  nB=1; nF=0; 
  basisMixon[[nB+1,nF+1]]
\end{mmaCell}
\begin{mmaCell}{Output}
  \{<|"nB"->1, "degB"->0, "nF"->0, "degF"->0, "l"->0, 
  "states"->\{\{\{\{1.\}\}\}\}|>\}
\end{mmaCell}
% Of course this means at many particle number sectors there is no state. 
% \begin{mmaCell}{Input}
%   basisMixon[[1, 1]]
%   basisMixon[[13, 3]]
% \end{mmaCell}
% \begin{mmaCell}{Output}
%   \{\}
%   \{\}
% \end{mmaCell}
For a non-trivial set
\begin{mmaCell}[moredefined={basisMixon}]{Input}
  nB=2; nF=3; 
  \{#nB,#degB,#nF,#degF,#l\}&/@basisMixon[[nB+1,nF+1]]//Column
\end{mmaCell}
\begin{mmaCell}{Output}
  \{2,0,3,3,0\}
  \{2,0,3,3,1\}
  \{2,0,3,3,2\}
  \{2,0,3,5,0\}
  \{2,2,3,3,0\}
\end{mmaCell}

For each level specified by {\tt \{nB, degB, nF, degF, l\}}, there can be a number of states, each specified by {\tt (l+1)} blocks of coeffcients where each block is a matrix of coefficients multiplying the matrix of mixon monomials given by
{\tt monomialsBoson[nB, degB + m]} $\otimes$ {\tt monomialsFermion[nF, degF + l - m]} where {\tt m = 0,1,...,l}.
For example:
\begin{mmaCell}[moredefined={basisMixon}]{Input}
  nB=2; nF=2; 
  example=basisMixon[[nB+1,nF+1,5]]
\end{mmaCell}
\begin{mmaCell}{Output}
  <|"nB"->2, "degB"->0, "nF"->2, "degF"->1, "l"->4, 
 "states"->\{\{\{\{-0.0778817,-0.0684043,-0.0263288\}\}, \{\{0.289617, 
      0.20479\}\}, \{\{-0.434425,-0.194281\}, \{-0.354707,-0.15863\}\}, 
\{\{0.388562\}, \{0.475889\}\}, \{\{-0.175534\}, \{-0.222035\}, \{-0.166527\}\}\}\}|>
\end{mmaCell}
there is only one state in the level, the state is specified by coefficients
\begin{mmaCell}[moredefined={example}]{Input}
  example["states"][[1]] // Column
\end{mmaCell}
\begin{mmaCell}{Output}
  \{\{-0.0778817,-0.0684043,-0.0263288\}\}
  \{\{0.289617,0.20479\}\}
  \{\{-0.434425,-0.194281\},\{-0.354707,-0.15863\}\}
  \{\{0.388562\},\{0.475889\}\}
  \{\{-0.175534\},\{-0.222035\},\{-0.166527\}\}
\end{mmaCell}
multiplying the monomials
\begin{mmaCell}[moredefined={monomialsBoson,monomialsFermion}]{Input}
  With[\{nB=2,nF=2,degB=0,degF=1,l=4\},
    Table[Outer[
      List[Flatten[\{#1,#2\}]]\&,
      monomialsBoson[nB,degB+m],
      monomialsFermion[nF,degF+l-m],1],
    \{m,0,l\}] 
  ] // Column
\end{mmaCell}
\begin{mmaCell}{Output}
  \{\{\{\{1,1,6,1\}\},\{\{1,1,5,2\}\},\{\{1,1,4,3\}\}\}\}
  \{\{\{\{2,1,5,1\}\},\{\{2,1,4,2\}\}\}\}
  \{\{\{\{3,1,4,1\}\},\{\{3,1,3,2\}\}\},\{\{\{2,2,4,1\}\},\{\{2,2,3,2\}\}\}\}
  \{\{\{\{4,1,3,1\}\}\},\{\{\{3,2,3,1\}\}\}\}
  \{\{\{\{5,1,2,1\}\}\},\{\{\{4,2,2,1\}\}\},\{\{\{3,3,2,1\}\}\}\}
\end{mmaCell}
which represents the state
\begin{equation}
\begin{aligned}
\ket{\CO}&=\\
&-0.0778817\ket{\d\phi\d\phi\d^6\psi\d\psi}
-0.0684043\ket{\d\phi\d\phi\d^5\psi\d^2\psi}
-0.0263288\ket{\d\phi\d\phi\d^4\psi\d^3\psi} \\
&+0.289617\ket{\d^2\phi\d\phi\d^5\psi\d\psi}
+0.20479\ket{\d^2\phi\d\phi\d^4\psi\d^2\psi}\\
&-0.434425\ket{\d^3\phi\d\phi\d^4\psi\d\psi}
-0.194281\ket{\d^3\phi\d\phi\d^3\psi\d^2\psi}\\
&-0.354707\ket{\d^2\phi\d^2\phi\d^4\psi\d\psi}
-0.15863\ket{\d^2\phi\d^2\phi\d^3\psi\d^2\psi}\\
&+0.388562\ket{\d^4\phi\d\phi\d^3\psi\d\psi}
+0.475889\ket{\d^3\phi\d^2\phi\d^3\psi\d\psi}\\
&-0.175534\ket{\d^5\phi\d\phi\d^2\psi\d\psi}
-0.222035\ket{\d^4\phi\d^2\phi\d^2\psi\d\psi}
-0.166527\ket{\d^3\phi\d^3\phi\d^2\psi\d\psi} \, .
\end{aligned}\nn
\end{equation}
(We have left off the ${\rm RQ}$ subscripts for conciseness in the above states).

\subsection{{\tt MatrixElements-Scalar.wl}} The package {\tt MatrixElements-Scalar.wl} contains routines relevant for computing the $\phi^2$ and $\phi^4$ matrix elements.

This package contains three main functions that the user can call: \begin{itemize}
	\item {\tt ComputeScalarMassMatrix[}$\Delta${\tt max}, {\tt basisBoson]}, which computes the mass term matrix elements from the $\phi^2$ term. The output is stored in the variable {\tt fullMassMatrix}.
	\item {\tt ComputePhi4NtoNMatrix[}$\Delta${\tt max}, {\tt basisBoson]}, which computes the $n$-to-$n$ matrix elements from the $\phi^4$ interaction term.  The output is stored in the variable {\tt fullPhi4NtoNMatrix}.
	\item {\tt ComputePhi4NtoNPlus2Matrix[}$\Delta${\tt max}, {\tt basisBoson]}, which computes the $n$-to-$(n+2)$ matrix elements from the $\phi^4$ interaction term. he output is stored in the variable {\tt fullPhi4NtoNPlus2Matrix}.
\end{itemize} The arguments for all of these functions work in the same way: the first argument {\tt$\Delta$max} instructs the desired function to compute the matrix elements up to and including the scaling dimension $\Delta_{\textrm{max}}$. The second argument {\tt basisBoson} is the output of the package {\tt Basis-Scalar.wl} (that is, the scalar basis tabulated up to and including $\Delta_{\textrm{max}}$). Note that this means that the first argument {\tt$\Delta$max} \textit{cannot exceed} the truncation $\Delta_{\textrm{max}}$ that was chosen for {\tt basisBoson}!

For example, suppose the user has run {\tt Basis-Scalar.wl} successfully and has obtained the scalar basis up to $\Delta_{\textrm{max}} = 20$ and it is stored in the variable {\tt basisBoson}. Then, to obtain, e.g. the $n$-to-$n$ matrix elements, we can input \begin{mmaCell}[moredefined={ComputePhi4NtoNMatrix,basisBoson}]{Input}
  ComputePhi4NtoNMatrix[20,basisBoson]
\end{mmaCell}
The output is a $627 \times 627$ matrix (since there are 627 states at this $\Delta_{\textrm{max}}$) wrapped as a {\tt SparseArray} in the variable {\tt fullPhi4NtoNMatrix}. For example, we can look at the first few elements of this matrix with the command \begin{mmaCell}[moredefined={fullPhi4NtoNMatrix}]{Input}
  fullPhi4NtoNMatrix[[1;;5,1;;5]] // MatrixForm
\end{mmaCell}
The conventions for {\tt ComputePhi4NtoNMatrix} and {\tt ComputePhi4NtoNPlus2Matrix} are that all numerical factors except the coupling constant $\lambda$ are absorbed into the output matrices. 

%So, for example, to compute the Hamiltonian in $\phi^4$ theory, we can define {\tt fullHamiltonian[$\lambda$\_]:= fullMassMatrix + $\lambda$ (fullPhi4NtoNMatrix + 
%fullPhi4NtoNPlus2Matrix);}.

There are several auxiliary functions within {\tt MatrixElements-Scalar.wl} that are used internally within the package. The user may wish to call them, and we list their functionality here for completeness. \begin{itemize}
	\item {\tt massNtoN[nR,$\Delta$max]}, which computes the monomial mass matrix. The output is the mass term matrix evaluated for monomials.
  \item {\tt phi4NtoN[nR,$\Delta$max]}, which computes the monomial $n$-to-$n$ interaction matrices. The output is the $n$-to-$n$ matrix evaluated for monomials. 
  \item {\tt phi4NtoNPlus2[nR,$\Delta$max]}, which computes the monomial $n$-to-$(n+2)$ interaction matrices. Note that the output here is not a square matrix, as there are typically more $(n+2)$-particle monomials than $n$-particle monomials.
  \item {\tt phiAnnihilateMap[nR,$\Delta$max]}, which determines the matrix representation of radial quantization annihilation modes (see section 7.6 of main paper). This functions output a sparse array that is the representation of $a_k$ on a set of monomials labelled by occupation number. The related functions {\tt phiAnnihilateTwoMap}, and {\tt phiAnnihilateThreeMap} do the same but with $a_k^2$ and $a_k^3$.
\end{itemize} The arguments for all of these functions are the same: they compute the desired function a given particle number {\tt nR} and up to $\Delta_{\textrm{max}}$ {\tt $\Delta$max}. The organization of the monomials for the monomial matrix elements matches that of the basis states.

\subsection{{\tt MatrixElements-Mixon-XXX.wl}}

There are six packages for mixon matrix elements that all work in essentially the same way, but produce matrix elements for different operators.  These are {\tt MatrixElements-Mixon-XXX.wl} with {\tt XXX} = {\tt Mass},{\tt Phi3}, {\tt Phi4}, {\tt Yukawa}, {\tt QPlus}, and {\tt QMinus} (the ``{\tt Mixon}'' has been dropped from the package title for the last three of these since there is no scalar-only or fermion-only version of them).

We will describe {\tt MatrixElements-Mixon-Mass.wl} first, and then briefly summarize how the others differ.


\subsubsection*{{\tt MatrixElements-Mixon-Mass.wl}}

The package {\tt MatrixElements-Mixon-Mass.wl} contains routines relevant for computing matrix elements for both the scalar and fermion mass term, where the external states are so-called ``mixon'' states containing both scalars and fermions. This package contains one main function that the user can call:
\begin{itemize}
\item {\tt computeMixonMassMatrices[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for both the scalar and fermion mass term. The output is two matrices, whose entries correspond to matrix elements between the states in {\tt basisMixon}, which are stored in the variables {\tt matScalarMass} and {\tt matFermionMass}.
\end{itemize}
The package creates two files to save the output, located in the directory specified by {\tt fdr}, which are labeled by the first argument {\tt $\De$maxSuffix}. For example, for {\tt $\De$maxSuffix$=20$}, the package would create the two files:
\begin{itemize}
\item {\tt MatrixScalarMassMixonD20}, containing the $\phi^2$ matrix elements in the variable {\tt matScalarMass},
\item {\tt MatrixFermionMassMixonD20}, containing the $\psi\fr{1}{\p}\psi$ matrix elements in the variable {\tt matFermionMass}.
\end{itemize}
The argument {\tt $\De$maxSuffix} only specifies the names for the output files, and does not affect any part of the evaluation. The package simply computes all matrix elements for the input basis {\tt basisMixon}. Only matrix elements between states with the same number of scalars and fermions will be nonzero.

\subsubsection*{{\tt MatrixElements-Mixon-Phi3.wl}}

The package {\tt MatrixElements-Mixon-Phi3.wl} computes mixon matrix elements for the $\phi^3$ interaction.  The  main user function is:
\begin{itemize}
\item {\tt computePhi3Matrices[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for  the $\phi^3$ interaction. The output is a matrix, whose entries correspond to matrix elements between the states in {\tt basisMixon}, which are stored in the variable {\tt matPhi3NtoN1}.
\end{itemize}
%The package creates one file to save the output, located in the directory specified by {\tt fdr}, which is labeled by the first argument {\tt $\De$max}. 
For example, for {\tt $\De$maxSuffix$=20$}, the package would create the file:
\begin{itemize}
\item {\tt MatrixPhi3NtoN1MixonD20}, containing the $\phi^3$ matrix elements in the variable {\tt matPhi3NtoN1}.
\end{itemize}
%The argument {\tt $\De$max} only specifies the names for the output files, and does not affect any part of the evaluation. The package simply computes all matrix elements for the input basis {\tt basisMixon}. 
Only matrix elements between states with the same number of fermions and whose number of scalars differ by $1$ will be nonzero.

\subsubsection*{{\tt MatrixElements-Mixon-Phi4.wl}}

The package {\tt MatrixElements-Mixon-Phi4.wl} computes mixon matrix elements for the $\phi^4$ interaction. The main user function is
\begin{itemize}
\item {\tt computePhi4Matrices[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for  the $\phi^4$ interaction. The output is two matrices, whose entries correspond to the $n \ra n$ and $n \ra n+2$ matrix elements between the states in {\tt basisMixon}, which are stored in the variables {\tt matPhi4NtoN} and {\tt matPhi4NtoN2}.
\end{itemize}
%The package creates two files to save the output, located in the directory specified by {\tt fdr}, which are labeled by the first argument {\tt $\De$max}. 
For example, for {\tt $\De$maxSuffix$=20$}, the package would create the two files:
\begin{itemize}
\item {\tt MatrixPhi4NtoNMixonD20}, containing the $n \ra n$ matrix elements in the variable {\tt matPhi4NtoN},
\item {\tt MatrixPhi4NtoN2MixonD20}, containing the $n \ra n+2$ matrix elements in the variable {\tt matPhi4NtoN2}.
\end{itemize}
%The argument {\tt $\De$max} only specifies the names for the output files, and does not affect any part of the evaluation. The package simply computes all matrix elements for the input basis {\tt basisMixon}. 
Only matrix elements between states with the same number of fermions and whose number of scalars differ by $0$ or $2$ will be nonzero.

\subsubsection*{{\tt MatrixElements-Yukawa.wl}}

The package {\tt MatrixElements-Yukawa.wl} computes mixon matrix elements for the Yukawa $\phi \psi \chi$ interaction, which in lightcone becomes two interactions, a cubic $\sim \phi \psi \frac{1}{\partial} \psi$ and a quartic $\sim \phi \psi \frac{1}{\partial} \phi \psi$. The main user function is
\begin{itemize}
\item {\tt computeYukawaMatrices[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for both the cubic and quartic interactions. The output is two matrices,  stored in the variables {\tt matYukawaCubic} and {\tt matYukawaQuartic}, for the cubic and quartic matrix elements, respectively.
\end{itemize}
%For example, for {\tt $\De$maxSuffix$=20$}, the package would create the two files:
%\begin{itemize}
%\item {\tt MatrixPhi4NtoNMixonD20}, containing the $n \ra n$ matrix elements in the variable {\tt matPhi4NtoN},
%\item {\tt MatrixPhi4NtoN2MixonD20}, containing the $n \ra n+2$ matrix elements in the variable {\tt matPhi4NtoN2}.
%\end{itemize}

\subsubsection*{{\tt MatrixElements-QPlus.wl}}

The package {\tt MatrixElements-QPlus.wl} computes mixon matrix elements for the supercharge $Q_+$ for a mass term $Q_+ \sim \phi \psi$ and a cubic term $Q_+ \sim \phi^2 \psi$.   The main user function is
\begin{itemize}
\item {\tt computeQPlusMatrix[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for both the mass and cubic terms. The output is two matrices,  stored in the variables {\tt matQPlusMass} and {\tt matQPlusInt}.
\end{itemize}

\subsubsection*{{\tt MatrixElements-QMinus.wl}}

The package {\tt MatrixElements-QMinus.wl} computes mixon matrix elements for the supercharge $Q_- \sim \p \phi \psi$.   The main user function is
\begin{itemize}
\item {\tt computeQMinusMatrix[$\De$maxSuffix,basisMixon,fdr]}, which computes all matrix elements for $Q_-$. The output is a matrix,  stored in the variables {\tt matQMinus}.
\end{itemize}



\section{Demos}

\subsection{Simple Scalar Code}

The file {\tt SimpleScalarCode.nb} provides a demonstration of the application of LCT to $\phi^4$ theory,
\be
\Lcal = \half \p_\mu\phi\p^\mu\phi - \half m^2 \phi^2 - \fr{1}{4!} \lambda \phi^4.
\ee
This notebook is self-contained (i.e.~needs no external packages) and uses the example code presented in section 4. The goal of this notebook is to provide a simple, readable example of the main steps in LCT. This code is much less efficient than the main packages, and can only be used to study low values of $\Dmax$ ($\lesssim 10$).

There are three sections in the notebook:
\begin{itemize}
\item \textbf{Construct Basis}\newline
The first section constructs a complete, orthonormal basis of primary states in free scalar field theory, following the methods in sections 4.1 and 4.2. There are two main functions in this section: {\tt PrimarySetSimp[n,deg]}, which constructs all primary operators with particle number $n$ and scaling dimension $\De=${\tt deg+n}, and {\tt orthoPrimaries[n,deg]} which orthonormalizes the primary operators at level ({\tt n,deg}) with respect to the momentum space inner product. Using these functions, we reproduce the $\Dmax=5$ basis in Table 5.
\item \textbf{Matrix Elements} \newline
The second section constructs the Hamiltonian matrix elements in the basis of primary operators for the $\phi^2$ and $\phi^4$ deformations, following the methods of section 4.3 and 4.4. There are three main functions, which all have very similar structure: {\tt PrimaryMassMatrix[n,deg1,deg2]} which computes the $\phi^2$ matrix elements between all states at level ({\tt n,deg1}) and those at level ({\tt n,deg2}), {\tt PrimaryNtoNMatrix[n,deg1,deg2]} which computes the $\phi^4$ matrix elements between all states at levels ({\tt n,deg1}) and ({\tt n,deg2}), and {\tt PrimaryNtoN2Matrix[n,deg1,deg2]} which computes the $\phi^4$ matrix elements between all states at level ({\tt n,deg1}) and those at level ({\tt n+2,deg2}). Using these functions, we reproduce the $\Dmax=5$ matrix elements in Tables 7 and 9, and compute the mass gap as a function of the dimensionless $\phi^4$ coupling $\fr{\lambda}{4\pi m^2}$.
\item \textbf{Spectral Densities} \newline
The final section constructs the overlaps between the operators $\phi^n$ and the basis of primary operators, following the method of section 4.6. There is one main function: {\tt primaryPhiN[n,deg]} which computes the overlap of $\phi^n$ with all basis states at level ({\tt n,deg}). Using this function, we compute the integrated spectral density for $\phi^2$ in the free massive theory ($\lambda=0$) with $\Dmax=20$.
\end{itemize}

\subsection{2D QCD}
\label{sec:2dQCD}
 In the folder {\tt ./documentation/QCD Demo/}, we have included files to work through the 2d massless QCD example presented in section 6 of the main paper. In particular, the notebook {\tt runQCD.nb} includes functions to study the theory described by the Lagrangian \begin{equation}
  \Lcal= i \Psibar \slashed{D} \Psi - \frac{1}{2}\Tr F_{\mu\nu}F^{\mu\nu},
\end{equation} and produce all figures shown in section 6. We briefly describe the general structure and functions of this notebook below (more comments may be found within the notebooks).

Roughly, {\tt runQCD.nb} is divided into two parts. The first part (\textbf{Section 1. The symbolic package}) includes symbolic functions that can be used to compute basis states and matrix elements as symbolic functions of the number of colors $N_c$. We also include a demonstration of how to use the functions from the first part. Since everything is done analytically in the first part, there is a trade-off in computation speed. The second part (\textbf{Section 2. The numerical package}) of the package includes faster numerical based functions. This requires setting $N_c$ to a desired value before running the functions. Note that none of the functions in {\tt runQCD.nb} use the radial quantization improvements developed in part II of the main paper, which we leave to future work.

In the first part of {\tt runQCD.nb}, we include the following sections:
\begin{itemize}
  \item \textbf{Generate the basis states recursively:} Here we include functions which symbolically compute 2d QCD primaries. The key function {\tt stateSet[dim]} computes primary states at dimension {\tt dim} by taking the double-trace combination of lower dimension primaries, starting with the seed primary $\psi^\dagg \psi$.
  \item \textbf{Inner products, color indices and contractions of spectators:} This section includes functions for computing finite $N_c$ inner products, which are needed to orthogonalize primaries obtained in the previous section. 
  \item \textbf{Gauge interaction: structure:} This section includes functions for computing the index structure of monomial gauge interaction matrix elements. It is roughly subdivided into three parts: the first part, which determines the gauge interaction structure for the `active' part of the matrix element. The second, which determines the the contribution from the `spectators'. And lastly, we put together these two steps to obtain the structure of final matrix element. More details about the gauge interaction may be found in Appendix D of the main paper.
  \item \textbf{Gauge interaction: active part:} Defines formulas for the active part of the gauge interaction for generic monomials.
  \item \textbf{Primary matrix elements:} Computes primaries, orthgoonalizes them, and puts together gauge interaction monomial matrix elements into gauge interaction matrix elements for primaries.
\end{itemize} In the following section (\textbf{Use the code}), we include a demonstration of how to use the functions described above, and the output they generate.

In the second part, we import the package {\tt QCD-public.wl}, which essentially includes numerical implementations of the functions in the first part. It includes the following sections:
\begin{itemize}
  \item \textbf{Compute the spectral density:} which computes the stress tensor spectral density shown in Fig. 9 of the main text for $N_c = 3$.
  \item \textbf{Use the spectral density to extract the low energy single particle spectrum:} where we identify single particle states in the stress tensor spectral density for $N_c=3$ and $N_c = 6$. We produce Fig. 10 of the main text.
\end{itemize}

Finally, in the standalone notebook {\tt LargeNDemo.nb}, we include expressions to compute analytic matrix elements at large $N_c$, in both the cosine and LCT basis. Using these matrix elements, we reproduce Figure 8 in [].

\subsection{Application I: $\phi^4$ Theory}

The folder {\tt Phi4Demo/} contains all files necessary to work through the first application presented in Part III, $\phi^4$ theory. In particular, the notebook {\tt Phi4Demo.nb} demonstrates how to use the packages {\tt Basis-Scalar.wl} and {\tt MatrixElements-Scalar.wl} to reproduce all figures in section 9.

The notebook {\tt Phi4Demo.nb} is divided into two main parts:
\begin{itemize}
\item \textbf{Generate Basis and Matrix Elements} \newline
The first part uses {\tt Basis-Scalar.wl} to construct the complete basis of states in free scalar theory up to the scaling dimension {\tt DMAX} (set by the user at the top of the notebook), then uses {\tt MatrixElements-Scalar.wl} to compute all $\phi^2$ and $\phi^4$ matrix elements for this basis. The output basis and matrix elements are saved in files labeled by {\tt DMAX}. For example, with {\tt DMAX}$=20$ (the default value) we obtain the files:
\begin{itemize}
\item {\tt BasisBosonD20.WXF}, containing the basis states,
\item {\tt ScalarMassD20.WXF}, containing the $\phi^2$ matrix elements,
\item {\tt ScalarPhi4NtoND20.WXF}, containing the $n\ra n$ $\phi^4$ matrix elements,
\item {\tt ScalarPhi4NtoN2D20.WXF}, containing the $n\ra n+2$ $\phi^4$ matrix elements.
\end{itemize}
The default value {\tt DMAX}$=20$ allows the user to keep the runtime and file sizes relatively small. To completely reproduce the figures in section 9, the user should set {\tt DMAX}$=40$.
\item \textbf{Diagonalize Hamiltonian and Reproduce Figures} \newline
The second part uses the output data from the first part to reproduce Figures 12-17. For each figure, the user can study results for any value of $\Dmax \leq${\tt DMAX}. Within this part, there are three main sections:
\begin{itemize}
\item \textbf{Mass Gap vs Coupling (Figure 12)} \newline
First, we diagonalize the full Hamiltonian for a range of values for the coupling $\lambda$. Because the theory has a $\mathbb{Z}_2$ symmetry $\phi \ra -\phi$, the Hamiltonian can be split into odd and even particle number sectors, which can be diagonalized independently. We use the results to reproduce Figure 12, showing the one-, two-, and three-particle thresholds as a function of $\lambda$.
\item \textbf{Convergence with $\Dmax$ (Figure 13)} \newline
Next, we diagonalize the Hamiltonian at a fixed value of $\lambda$ (set by the user) for various values of $\Dmax$. We extrapolate these results to $\Dmax \ra \infty$ by fitting the error as $1/\Dmax^p$, where the user can vary $p$. We use these results to reproduce Figure 13, showing the convergence of the one-, two-, and three-particle thresholds with increasing $\Dmax$.
\item \textbf{Spectral Densities (Figures 14-17)} \newline
Finally, we diagonalize the Hamiltonian at a fixed value of $\lambda$ and compute spectral densities of the stress-energy tensor. We compute the Zamolodchikov C-function (Figures 14-16) as well as the integrated spectral density of the trace $T_{+-}$ (Figure 17). In comparing spectral density results for different values of $\Dmax$, it is best to keep the mass gap $\mu_{\gap}^2$ fixed, rather than the coupling $\lambda$. In order to do this, we also provide a section at the end which allows the user to specify $\Dmax$ and a desired value for $\mu_{\gap}^2$ (in units of the bare mass). The code then scans over $\lambda$ to construct an interpolating function $\lambda(\mu_{\gap}^2)$ and determines the value of the coupling needed to obtain the desired mass gap.
\end{itemize}
\end{itemize}

\subsection{Application II: Yukawa Theory}
There are two mathematica notebooks that demonstrate different parts of the non-SUSY Yukawa example described by the Lagrangian
\begin{equation}
\Lcal = \frac{1}{2} (\p \phi)^2 - \frac{1}{2}m_\phi^2 \phi^2 + \sqrt{2} i\psi\p_+\psi - \frac{1}{\sqrt{2}} \psi\frac{m_\psi^2 }{i\p} \psi - \sqrt{2}m_\psi g \phi \psi\frac{1}{i\p} \psi - \frac{g^2}{\sqrt{2}} \phi  \psi\frac{1}{i\p} \phi \psi  .
\label{eq:YukawaLCLag2}
\end{equation}

\paragraph{{\tt YukawaOneLoopMassShifts.nb}}
The file is in the path \\{\tt ./documentation/YukawaOneLoopMassShifts.nb}. The file walks through the calculation of second order time-independent perturbation theory to compute the one-loop mass shift of the one-fermion state, and reproduces Fig. 19 of the main text. The notebook does not use any packages.

\paragraph{{\tt Yukawa\_Demo.nb}}
The file is in the path \\{\tt ./documentation/Yukawa Demo/Yukawa\_Demo}. This is the main file that walks through the computation of LCT results of the Yukawa theory using the code packages. 

The file contains the following parts:
\begin{itemize}
\item \textbf{How to run the Yukawa package} \newline
This section introduces the basics of running the Yukawa packages. The reader can directly run the whole section and see instant results.
  \begin{itemize}
  \item \textbf{Run packages}\\
  This subsection introduces the basic commands to run the packages to compute the basis states and matrix elements at certain $\Dmax$. The default set is $\Dmax=6$ (set at the beginning) so running the whole section is instant. If the reader wishes to generate the data to reproduce the results in the main text, one can change this line to $\Dmax=20$ and it takes about 3 hours to finish.
  \item \textbf{Parse the computed data into readable forms}\\
  The raw output data of {\tt computeXXXX[...]} is hard to use. This subsection introduces the useful commands to flatten the states list and interaction matrix into readable forms which are used throughout the rest of the notebook.
  \item \textbf{Save data in more compact format}\\
  This subsection introduces the convention of importing/exporting data computed in previous subsections. Running this subsection will create (by default) $\Dmax=6$ data in exactly the same form as will be imported in the next section. Setting $\Dmax=20$ will override the pre-generated data.
  \end{itemize}
\item \textbf{Load previously computed data and parse}\\
This section loads the pre-generated (or user-generated if one sets $\Dmax=20$) data at $\Dmax=20$. Readers need to run this section before proceeding to later sections.
\item \textbf{Fermion Mass shift (Figures 20-21)}\\
This section computes the fermion mass shift for fermion multi-particle states, using the second order time-independent perturbation theory and the explicit Hamiltonian at $\Dmax$.
  \begin{itemize}
  \item \textbf{Old fashioned perturbation theory}\\
  This subsection defines and computes the intermediate results used in perturbation theory. 
  \item \textbf{Fig 20}\\
  This subsection tests two different schemes to cancel the fermion mass one-loop divergence -- using a local counter-term or a non-local one, by computing the one-loop fermion mass shift of 1- 2- and 3- particle states.
  \item \textbf{Fig 21}\\
  This subsection computes the one-loop fermion mass shift of 1- 2- and 3- particle states in the above two schemes. In addition to the divergence-canceling counter-terms, a finite local term is introduced to restore Lorentz covariance. 
  \end{itemize}
\item \textbf{The energy spectrum (Figure 22)}\\
This section computes the low energy spectrum of Yukawa theory at $m_\psi/m_\phi = 0.4$ and $0.8$, as a function of the coupling, $g$. This section may take a few minutes to run. In order to speed up, the scanning of $g$ takes larger step length than the actual plot in the main text.
\item \textbf{Spectral density (Figures 23-24)}\\
This section computes the spectral density.
  \begin{itemize}
  \item \textbf{Fig 23 - C function}\\
  This subsection computes the integrated spectral density of $T_{--}$, known as the Zamolodchikov C function. The plots shows the data at $\Dmax=20$ and $m_\psi/m_\phi = 0.4$ and $0.8$.
  \item \textbf{Fig 24 - $\<\phi\phi\>$ correlator}\\
  This subsection computes the spectral density of $\phi$ operator. The plots shows the data at $\Dmax=20$ and $m_\psi/m_\phi = 0.4$ at different $g$. The spectral density is compared with the Breit-Wigner distribution.
  \end{itemize}
\end{itemize}

\section{Troubleshooting}{\textbf{\color{red}We can add more when our beta testers get back to us.}} Here we enumerate potential errors / commonly asked questions that can arise when trying to use LCT code: \begin{itemize}
  \item The function {\tt BinarySerialize} or {\tt BinaryDeserialize} gives a ``Serialized data is corrupt and does not represent an expression'' error.
  \subitem This is likely due to running the code on an earlier version of Mathematica. LCT packages have been tested on Mathematica version 12.1.0, and older versions may generate error messages with {\tt BinarySerialize} or {\tt BinaryDeserialize} functions, especially when changing precision. We recommend updating Mathematica to 12.0.0 or later.
  \item Functions do not seem to compile / external libraries necessary for {\tt CompilationTarget} cannot be found.
  \subitem In order to optimize certain operations,  LCT packages pre-compile frequently called Mathematica functions using the {\tt Compile} function. These functions are translated into C code with the command {\tt CompilationTarget -> "C"}. This assumes that the user's machine has a suitable external C compiler. If one is not found, Mathematica defaults to {\tt CompilationTarget -> "WVM"} which creates code for the traditional Wolfram System virtual machine, at the expense of computational efficiency. We recommend installing a C compiler for fastest results. 
\end{itemize}





\end{document}
